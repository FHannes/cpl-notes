% Samenvatting van het vak Vergelijkende Studie van Imperatieve Programmeertalen
\documentclass[a4paper]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{parskip}
\usepackage[pdftex]{graphicx}
\usepackage[dutch]{babel}
\usepackage{amsmath}
\usepackage{float}
\usepackage{framed}
\usepackage{varwidth}
\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}

\lstset{
    language=Scheme,
    frame=leftline
}
\lstMakeShortInline[columns=fixed]|

\begin{document}

\begin{titlepage}
    \newpage
    \thispagestyle{empty}
    \frenchspacing
    \hspace{-0.2cm}
    \includegraphics[height=3.4cm]{assets/sedes}
    \hspace{0.2cm}
    \rule{0.5pt}{3.4cm}
    \hspace{0.2cm}
    \begin{minipage}[b]{8cm}
        \Large{Katholieke\newline Universiteit\newline Leuven}\smallskip\newline
        \large{}\smallskip\newline
        \textbf{Department of\newline Computer Science}\smallskip
    \end{minipage}
    \hspace{\stretch{1}}
    \vspace*{3.2cm}\vfill
    \begin{center}
        \begin{minipage}[t]{\textwidth}
            \begin{center}
                \large{\rm{\textbf{\uppercase{Notes}}}}\\
                \large{\rm{Comparative Programming Languages [H0S01a]}}\\
                \large{\rm{Vergelijkende Studie van Imperatieve Programmeertalen [H04L5a]}}
            \end{center}
        \end{minipage}
    \end{center}
    \vfill
    \hfill\makebox[8.5cm][l]{%
        \vbox to 7cm{\vfill\noindent
            {\rm \textbf{Fr\'ed\'eric Hannes}}\\[2mm]
            {\rm Academic year 2015--2016}
        }
    }
\end{titlepage}

\tableofcontents

\newpage

\section{Code}

\subsection{in-S?}

The set $S$ is defined as a set containing any natural number $n$ where $n = 0$ or $n - 3 \in S$. The procedure |in-S?| returns |#t| if a given value is part of the set $S$ and |#f| if it is not.

\begin{lstlisting}
(define in-S?
  (lambda (x)
    (if (zero? x) #t
        (if (< x 3) #f
            (in-S? (- x 3))))))
\end{lstlisting}

\subsection{list-length}

The procedure |list-length| returns the number of elements in a given list. This functionality is available as |length| in the Racket API.

\begin{lstlisting}
(define list-length
  (lambda (l)
    (if (null? l)
        0
        (+ 1 (list-length (cdr l))))))
\end{lstlisting}

\subsection{nth-element}

The procedure |nth-element| returns the element from a given list at a given position. This functionality is available as |list-ref| in the Racket API.

\begin{lstlisting}
(define report-list-too-short
  (lambda (n)
    (eopl:error 'nth-element
                "List too short by ~s elements.~%" (+ n 1))))

(define nth-element
  (lambda (l p)
    (if (null? l)
        (report-list-too-short p)
        (if (zero? p)
            (car l)
            (nth-element (cdr l) (- p 1))))))
\end{lstlisting}

\subsection{remove-first}

The procedure |remove-first| returns a given list without the first occurrence of a given symbol. If the list is empty, an empty list is returned. If the list does not contain the given symbol, the given list is returned. This functionality is available as |remv| in the Racket API.

\begin{lstlisting}
(define remove-first
  (lambda (s l)
    (if (null? l)
        '()
        (if (eqv? (car l) s)
            (cdr l)
            (cons (car l) (remove-first s (cdr l)))))))
\end{lstlisting}

\newpage

\section{Exercises}

\subsection{Chapter 1}

\subsubsection*{1.6}

If we reversed the order of checks in |nth-element|, nothing would go wrong, but we would have to perform the initial check in both branches of the |if| for the second check.

\subsubsection*{1.7}

We introduce a helper procedure |nth-element-helper| to easily preserve the original given list.

\begin{lstlisting}
(define report-list-too-short
  (lambda (l n)
    (eopl:error 'nth-element
                "~s does not have ~s element(s).~%" l (+ (length l) (+ n 1)))))

(define nth-element-helper
  (lambda (ol l p)
    (if (null? l)
        (report-list-too-short ol p)
        (if (zero? p)
            (car l)
            (nth-element-helper ol (cdr l) (- p 1))))))

(define nth-element
  (lambda (l p)
    (nth-element-helper l l p)))
\end{lstlisting}

\subsubsection*{1.8}

If the last line of |remove-first| were to be replaced with |(remove-first s (cdr l))|, it would be defined as:

\textbf{remote-first} : \textit{Sym $\times$ Listof(Sym) $\rightarrow$ Listof(Sym)}\\
\textbf{usage:} |(remove-first s l)| returns a list with all elements starting after the first occurrence of the symbol s in the list l.

\subsubsection*{1.9}

We define |remove| as a procedure which removes every occurrence of a given symbol from a given list.

\begin{lstlisting}
(define remove
  (lambda (s l)
    (if (null? l)
        '()
        (if (eqv? (car l) s)
            (remove s (cdr l))
            (cons (car l) (remove s (cdr l)))))))
\end{lstlisting}

\newpage

\section{Racket (Scheme) Language Reference}

\subsection{API}

\subsubsection{car}

\begin{lstlisting}[frame=none]
(car l)
\end{lstlisting}

\textbf{Description}

Returns the first element of a given list |l|.

\textbf{Examples}

\begin{lstlisting}
> (car '(a b (c d) e))
a
\end{lstlisting}

\subsubsection{cdr}

\begin{lstlisting}[frame=none]
(cdr l)
\end{lstlisting}

\textbf{Description}

Returns the n-1 last elements of a given list |l| as a new list, where n is the length of the list |l|.

\textbf{Examples}

\begin{lstlisting}
> (cdr '(a b (c d) e))
(b (c d) e)
\end{lstlisting}

\subsubsection{cons}

\begin{lstlisting}[frame=none]
(cons a b)
\end{lstlisting}

\textbf{Description}

Returns a pair containing |a| and |b| if they are both symbols. If |b| is a list, it will return that list with |a| appended at the start.

\textbf{Examples}

\begin{lstlisting}
> (cons 'a 'b)
'(a . b)
\end{lstlisting}

\begin{lstlisting}
> (cons 'a '(b))
'(a b)
\end{lstlisting}

\subsubsection{define}

\begin{lstlisting}[frame=none]
(define id expr)
(define (head args) body)
\end{lstlisting}

\textbf{Description}

The first definition binds |id| to the result of |expr|. The second one binds a |head| with |args| to a |body|.

\textbf{Examples}

\begin{lstlisting}
(define x 10)

> x
10
\end{lstlisting}

\begin{lstlisting}
(define (f x)
  (+ x 1))
  
> (f 10)
11
\end{lstlisting}


\subsubsection{eq?}

\begin{lstlisting}[frame=none]
(eq? a b)
\end{lstlisting}

\textbf{Description}

Returns |#t| if 2 given values |a| and |b| refer to the same object. Basic values (and strings) will be compared by value, as they are not represented by objects. To compare by value, refer to |eqv?|.

\textbf{Examples}

\begin{lstlisting}
> (eq? 1 1)
#t
\end{lstlisting}

\begin{lstlisting}
> (eq? 'a 'a)
#f
\end{lstlisting}

\begin{lstlisting}
> (eq? '(a b) '(a b))
#f
\end{lstlisting}

\begin{lstlisting}
> (eq? "abc" "abc")
#t
\end{lstlisting}


\subsubsection{eqv?}

\begin{lstlisting}[frame=none]
(eqv? a b)
\end{lstlisting}

\textbf{Description}

Returns |#t| if 2 given values |a| and |b| are equivalent and |#f| if they are not. This means that the values are equal, but is not to be confused with the procedure |eq?|. This can be used as an alternative to |=| to compare any type of values, as |=| only compares numbers. |eqv?| can not be used to verify if 2 lists are equal, for this refer to |equal?|.

\textbf{Examples}

\begin{lstlisting}
> (eqv? 1 1)
#t
\end{lstlisting}

\begin{lstlisting}
> (eqv? 'a 'a)
#t
\end{lstlisting}

\begin{lstlisting}
> (eqv? '(a b) '(a b))
#f
\end{lstlisting}

\begin{lstlisting}
> (eqv? "abc" "abc")
#t
\end{lstlisting}

\subsubsection{if}

\begin{lstlisting}[frame=none]
(if test-expr then-expr else-expr)
\end{lstlisting}

\textbf{Description}

Evaluates |test-expr| and evaluates |then-expr| if the result was anything but |#f|, otherwise |else-expr| is evaluated.

\textbf{Examples}

\begin{lstlisting}
> (if (= 1 2) 3 4)
4
\end{lstlisting}

\subsubsection{lambda}

\begin{lstlisting}[frame=none,language=SchemeBasic,belowskip=0pt]
(lambda args body)
\end{lstlisting}
\begin{lstlisting}[frame=none,aboveskip=0pt]
(lambda args body)
\end{lstlisting}

\textbf{Description}

Produces an anonymous procedure with given |args| and |body|.

\textbf{Examples}

\begin{lstlisting}
> ((lambda (x) x) 10)
10
\end{lstlisting}

\subsubsection{let}

\begin{lstlisting}[frame=none]
(let ([id val-expr] ...) body)
\end{lstlisting}

\textbf{Description}

Assigns |val-expr| to |id| for a set of these pairs. After the assignment, |body| is evaluated with these new identifiers.

\textbf{Examples}

\begin{lstlisting}
> (let ([x 10] [y 5]) (+ x y))
15
\end{lstlisting}

\subsubsection{list-ref}

\begin{lstlisting}[frame=none]
(list-ref l p)
\end{lstlisting}

\textbf{Description}

Returns the element of a given list |l| at position |p|. The position if offset at 0.

\textbf{Examples}

\begin{lstlisting}
> (list-ref '(a b (c d) e) 2)
(c d)
\end{lstlisting}

\subsubsection{null?}

\begin{lstlisting}[frame=none]
(null? l)
\end{lstlisting}

\textbf{Description}

Returns |#t| if |l| is an empty list |'()| and |#f| is it is not.

\textbf{Examples}

\begin{lstlisting}
> (null? '())
#t
\end{lstlisting}

\subsubsection{symbol?}

\begin{lstlisting}[frame=none]
(symbol? s)
\end{lstlisting}

\textbf{Description}

Returns |#t| if |l| is a symbol and |#f| is it is not.

\textbf{Examples}

\begin{lstlisting}
> (symbol? 'a)
#t
\end{lstlisting}

\begin{lstlisting}
> (symbol? 1)
#f
\end{lstlisting}

\subsubsection{zero?}

\begin{lstlisting}[frame=none]
(zero? z)
\end{lstlisting}

\textbf{Description}

Returns |#t| if |z| is zero and |#f| is it is not.

\textbf{Examples}

\begin{lstlisting}
> (zero? 0)
#t
\end{lstlisting}

\end{document}

