% Samenvatting van het vak Vergelijkende Studie van Imperatieve Programmeertalen
\documentclass[a4paper]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{parskip}
\usepackage[pdftex]{graphicx}
\usepackage[dutch]{babel}
\usepackage{amsmath}
\usepackage{float}
\usepackage{framed}
\usepackage{varwidth}
\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}

\lstset{
    language=Scheme,
    frame=leftline
}
\lstMakeShortInline[columns=fixed]|

\begin{document}

\begin{titlepage}
    \newpage
    \thispagestyle{empty}
    \frenchspacing
    \hspace{-0.2cm}
    \includegraphics[height=3.4cm]{assets/sedes}
    \hspace{0.2cm}
    \rule{0.5pt}{3.4cm}
    \hspace{0.2cm}
    \begin{minipage}[b]{8cm}
        \Large{Katholieke\newline Universiteit\newline Leuven}\smallskip\newline
        \large{}\smallskip\newline
        \textbf{Department of\newline Computer Science}\smallskip
    \end{minipage}
    \hspace{\stretch{1}}
    \vspace*{3.2cm}\vfill
    \begin{center}
        \begin{minipage}[t]{\textwidth}
            \begin{center}
                \large{\rm{\textbf{\uppercase{Notes}}}}\\
                \large{\rm{Comparative Programming Languages [H0S01a]}}\\
                \large{\rm{Vergelijkende Studie van Imperatieve Programmeertalen [H04L5a]}}
            \end{center}
        \end{minipage}
    \end{center}
    \vfill
    \hfill\makebox[8.5cm][l]{%
        \vbox to 7cm{\vfill\noindent
            {\rm \textbf{Fr\'ed\'eric Hannes}}\\[2mm]
            {\rm Academic year 2015--2016}
        }
    }
\end{titlepage}

\tableofcontents

\newpage

\section{Info}

This document contains my notes for the course Comparative Programming Languages. It features code examples from the textbook used in the course, with some or a lot of explanation, depending on the complexity of the examples. I try to implement these myself first, if my implementation differs greatly from that of the textbook, I also add it to this document with an explanation of what I could've done better. After these examples, exercises and a modest Racket language reference guide are also present.

\newpage

\section{Code}

\subsection{in-S?}

The set $S$ is defined as a set containing any natural number $n$ where $n = 0$ or $n - 3 \in S$. The procedure |in-S?| returns |#t| if a given value is part of the set $S$ and |#f| if it is not.

\begin{lstlisting}
(define in-S?
  (lambda (x)
    (if (zero? x) #t
        (if (< x 3) #f
            (in-S? (- x 3))))))
\end{lstlisting}

\subsection{list-length}

The procedure |list-length| returns the number of elements in a given list. This functionality is available as |length| in the Racket API.

\textbf{list-length} : \textit{Listof(Sym) $\rightarrow$ Int}
\begin{lstlisting}[aboveskip=0pt]
(define list-length
  (lambda (lst)
    (if (null? lst)
        0
        (+ 1 (list-length (cdr lst))))))
\end{lstlisting}

\subsection{nth-element}

The procedure |nth-element| returns the element from a given list at a given position. This functionality is available as |list-ref| in the Racket API.

\textbf{report-list-too-short} : \textit{Listof(Sym) $\times$ Int $\rightarrow$ Error}
\begin{lstlisting}[aboveskip=0pt]
(define report-list-too-short
  (lambda (n)
    (eopl:error 'nth-element
                "List too short by ~s elements.~%" (+ n 1))))
\end{lstlisting}

\textbf{nth-element} : \textit{Listof(Sym) $\times$ Int $\rightarrow$ SchemeVal}
\begin{lstlisting}[aboveskip=0pt]
(define nth-element
  (lambda (lst n)
    (if (null? lst)
        (report-list-too-short n)
        (if (zero? n)
            (car lst)
            (nth-element (cdr lst) (- n 1))))))
\end{lstlisting}

\subsection{remove-first}

The procedure |remove-first| returns a given list without the first occurrence of a given symbol. If the list is empty, an empty list is returned. If the list does not contain the given symbol, the given list is returned. This functionality is available as |remv| in the Racket API.

\textbf{remove-first} : \textit{Sym $\times$ Listof(Sym) $\rightarrow$ Listof(Sym)}
\begin{lstlisting}[aboveskip=0pt]
(define remove-first
  (lambda (s los)
    (if (null? los)
        '()
        (if (eqv? (car los) s)
            (cdr los)
            (cons (car los) (remove-first s (cdr los)))))))
\end{lstlisting}

\subsection{occurs-free?}

The procedure |occurs-free?| evaluates a $\lambda$-calculus expression and returns |#t| if a given variable is not a bound variable in that expression. This means that it does not occur as a named parameter for any of the |lambda| expressions in the given expression.

\textbf{occurs-free?} : \textit{Sym $\times$ LcExp $\rightarrow$ Bool}
\begin{lstlisting}[aboveskip=0pt,numbers=left]
(define occurs-free?
  (lambda (var exp)
    (cond
      ((symbol? exp) (eqv? var exp))
      ((eqv? (car exp) 'lambda)
       (and
        (not (eqv? var (caadr exp)))
        (occurs-free? var (caddr exp))))
      (else
       (or
        (occurs-free? var (car exp))
        (occurs-free? var (cadr exp)))))))
\end{lstlisting}

\subsubsection*{Lines reference}

\begin{enumerate}
\setcounter{enumi}{3}
\item If |exp| is a symbol, which is |'| followed by a letter, then the given |var| is not bound if it equals |exp|.
\item If the first element of |exp| is |'lambda|, it is a lambda expression, which we have to dissect.
\setcounter{enumi}{6}
\item |(caadr exp)| returns the parameter of the |lambda| expression, which is referred to as the first (and only) value of the head of the expression. An expression in $\lambda$-calculus can only have a single parameter for each |lambda| expression. In essence, it first performs |cdr| to remove the leading |lambda| from the expression. Then it performs |car| to obtain the head of the expression and finally it will perform another |car| to get the (first) element inside of the head.
\item |(caddr exp)| returns the body of the expression. This is only called if the previous line did not evaluate to |#f|. That means that the head of the expression did not contain |var| and then we can proceed to evaluate the body with a recursive call to |occurs-free?|.
\setcounter{enumi}{10}
\item Aside from the previous cases, $\lambda$-calculus also has expressions that come in pairs of 2. First we will extract the first value of the pair using |car| and evaluate that with a recursive call to |occurs-free?|.
\item To grab the second value of the pair, we have to first get the list of expressions symbols that does not contain the initial symbol, which we've already evaluated using |cdr| and next get the first (and only) symbol of that list using |car|. This line is only executed, if the previous line did not evaluate to |#t|.
\end{enumerate}

\subsection{subst}

The procedure |subst| takes 2 symbols and an s-list, which is defined as a list containing symbols and/or s-lists. The procedure should replace every occurrence of one of the given symbols in the list and all nested lists by the other given symbol, referred to as |old| and |new| respectively.

\subsubsection*{First attempt}

\textbf{subst} : \textit{Sym $\times$ Sym $\times$ S-list $\rightarrow$ S-list}
\begin{lstlisting}[aboveskip=0pt]
(define subst
  (lambda (new old slist)
    (if (null? slist)
        '()
        (if (symbol? (car slist))
            (cons (if (eqv? (car slist) old)
                      new
                      (car slist)) (subst new old (cdr slist)))
            (cons (subst new old (car slist)) (subst new old (cdr slist)))))))
\end{lstlisting}

My first attempt can be improved by extracting the |cons| call from both expressions passed to the second |if| call, as the second expression in each |cons| call is the same.

\subsubsection*{Textbook}

\textbf{subst} : \textit{Sym $\times$ Sym $\times$ S-exp $\rightarrow$ S-exp}
\begin{lstlisting}[aboveskip=0pt]
((define subst-in-s-exp
  (lambda (new old sexp)
    (if (symbol? sexp)
        (if (eqv? sexp old) new sexp)
        (subst new old sexp))))
\end{lstlisting}

\textbf{subst} : \textit{Sym $\times$ Sym $\times$ S-list $\rightarrow$ S-list}
\begin{lstlisting}[aboveskip=0pt]
(define subst
  (lambda (new old slist)
    (if (null? slist)
        '()
        (cons
         (subst-in-s-exp new old (car slist))
         (subst new old (cdr slist))))))
\end{lstlisting}

\newpage

\section{Exercises}

\subsection{Chapter 1}

\subsubsection*{1.6}

If we reversed the order of checks in |nth-element|, nothing would go wrong, but we would have to perform the initial check in both branches of the |if| for the second check.

\subsubsection*{1.7}

We introduce a helper procedure |nth-element-helper| to easily preserve the original given list.

\begin{lstlisting}
(define report-list-too-short
  (lambda (lst n)
    (eopl:error 'nth-element
                "~s does not have ~s element(s).~%" l (+ (length l) (+ n 1)))))

(define nth-element-helper
  (lambda (origlst lst n)
    (if (null? lst)
        (report-list-too-short origlst n)
        (if (zero? n)
            (car lst)
            (nth-element-helper origlst (cdr lst) (- n 1))))))

(define nth-element
  (lambda (lst n)
    (nth-element-helper lst lst n)))
\end{lstlisting}

\subsubsection*{1.8}

If the last line of |remove-first| were to be replaced with |(remove-first s (cdr los))|, it would be defined as:

\textbf{remote-first} : \textit{Sym $\times$ Listof(Sym) $\rightarrow$ Listof(Sym)}\\
\textbf{usage:} |(remove-first s los)| returns a list with all elements starting after the first occurrence of the symbol |s| in the list |los|.

\subsubsection*{1.9}

We define |remove| as a procedure which removes every occurrence of a given symbol from a given list.

\begin{lstlisting}
(define remove
  (lambda (s l)
    (if (null? l)
        '()
        (if (eqv? (car l) s)
            (remove s (cdr l))
            (cons (car l) (remove s (cdr l)))))))
\end{lstlisting}

\subsubsection*{1.10}

Though typically ``or'' refers to ``inclusive or'', ``exclusive or'' also exists. The statement ``A or B'' for the inclusive variant, will evaluate to true (if it is a logical expression) when either A and/or B are true. The exclusive variant, often referred to as ``xor'', will for ``A xor B'' only evaluate to true if A or B are true, but not when both are true or false.

\subparagraph{NOTE} When we refer to bitwise operations, rather than logical ones, ``A or B'' will perform the same logic as it would for a logical expression, at the binary level. E.g. ``1001 or 0101'' evaluates to 1101, which translates to the decimal system as ``9 or 5 = 13''. ``1001 xor 0101'' evaluates to 1100, which translates to the decimal system as ``9 xor 5 = 12''.

\subsubsection*{1.11}

The |subst-in-s-exp| procedure is called with the first element of the parameter |slist| in |subst|, it only passes this back to |subst| if it is not a symbol. This means it works down into the tree of nested lists. Once the deepest nested list has been reached, recursion will automatically halt.

\subsubsection*{1.12}

The procedure |subst| defined below has |subst-in-s-exp| inlined.

\begin{lstlisting}
(define subst
  (lambda (new old slist)
    (if (null? slist)
        '()
        (cons
         (if (symbol? (car slist))
             (if (eqv? (car slist) old) new (car slist))
             (subst new old (car slist)))
         (subst new old (cdr slist))))))
\end{lstlisting}

\subsubsection*{1.13}

The procedure |map| is used to process the slist in the altered version of |subst|.

\begin{lstlisting}
(define subst
  (lambda (new old slist)
    (map (lambda (sexp)
           (if (symbol? sexp)
               (if (eqv? sexp old) new sexp)
               (subst new old sexp))) slist)))
\end{lstlisting}

\subsubsection*{1.15}

The procedure |duple| returns a list with an input value duplicated a certain number of times.

\begin{lstlisting}
(define duple
  (lambda (n x)
    (if (zero? n)
        '()
        (cons x (duple (- n 1) x)))))
\end{lstlisting}

\subsubsection*{1.16}

The procedure |invert| swaps the elements of every pair in a list of pairs.

\begin{lstlisting}
(define invert
  (lambda (lst)
    (if (null? lst)
        '()
        (cons
         (list (cadar lst) (caar lst))
         (invert (cdr lst))))))
\end{lstlisting}

\subsubsection*{1.17}

The procedure |down| wraps every top-level element of a given list in a list.

\begin{lstlisting}
(define down
  (lambda (lst)
    (if (null? lst)
        '()
        (cons
         (cons (car lst) '())
         (down (cdr lst))))))
\end{lstlisting}

\subsubsection*{1.18}

The procedure |swapper| swaps every given 2 symbols in a given list and its nested lists.

\begin{lstlisting}
(define swapper
  (lambda (s1 s2 slist)
    (map
     (lambda (elem)
       (if (symbol? elem)
           (if (eqv? elem s1)
               s2
               (if (eqv? elem s2) s1 elem))
           (swapper s1 s2 elem)))
     slist)))
\end{lstlisting}

\newpage

\section{Racket (Scheme) Language Reference}

\subsection{API}

\subsubsection{car}

\begin{lstlisting}[frame=none]
(car l)
\end{lstlisting}

\textbf{Description}

Returns the first element of a given list |l|.

\textbf{Examples}

\begin{lstlisting}
> (car '(a b (c d) e))
a
\end{lstlisting}

\subsubsection{cdr}

\begin{lstlisting}[frame=none]
(cdr l)
\end{lstlisting}

\textbf{Description}

Returns the n-1 last elements of a given list |l| as a new list, where n is the length of the list |l|.

\textbf{Examples}

\begin{lstlisting}
> (cdr '(a b (c d) e))
(b (c d) e)
\end{lstlisting}

\subsubsection{cons}

\begin{lstlisting}[frame=none]
(cons a b)
\end{lstlisting}

\textbf{Description}

Returns a pair containing |a| and |b| if they are both symbols. If |b| is a list, it will return that list with |a| appended at the start.

\textbf{Examples}

\begin{lstlisting}
> (cons 'a 'b)
'(a . b)
\end{lstlisting}

\begin{lstlisting}
> (cons 'a '(b))
'(a b)
\end{lstlisting}

\subsubsection{define}

\begin{lstlisting}[frame=none]
(define id expr)
(define (head args) body)
\end{lstlisting}

\textbf{Description}

The first definition binds |id| to the result of |expr|. The second one binds a |head| with |args| to a |body|.

\textbf{Examples}

\begin{lstlisting}
(define x 10)

> x
10
\end{lstlisting}

\begin{lstlisting}
(define (f x)
  (+ x 1))
  
> (f 10)
11
\end{lstlisting}


\subsubsection{eq?}

\begin{lstlisting}[frame=none]
(eq? a b)
\end{lstlisting}

\textbf{Description}

Returns |#t| if 2 given values |a| and |b| refer to the same object. Basic values (and strings) will be compared by value, as they are not represented by objects. To compare by value, refer to |eqv?|.

\textbf{Examples}

\begin{lstlisting}
> (eq? 1 1)
#t
\end{lstlisting}

\begin{lstlisting}
> (eq? 'a 'a)
#f
\end{lstlisting}

\begin{lstlisting}
> (eq? '(a b) '(a b))
#f
\end{lstlisting}

\begin{lstlisting}
> (eq? "abc" "abc")
#t
\end{lstlisting}


\subsubsection{eqv?}

\begin{lstlisting}[frame=none]
(eqv? a b)
\end{lstlisting}

\textbf{Description}

Returns |#t| if 2 given values |a| and |b| are equivalent and |#f| if they are not. This means that the values are equal, but is not to be confused with the procedure |eq?|. This can be used as an alternative to |=| to compare any type of values, as |=| only compares numbers. |eqv?| can not be used to verify if 2 lists are equal, for this refer to |equal?|.

\textbf{Examples}

\begin{lstlisting}
> (eqv? 1 1)
#t
\end{lstlisting}

\begin{lstlisting}
> (eqv? 'a 'a)
#t
\end{lstlisting}

\begin{lstlisting}
> (eqv? '(a b) '(a b))
#f
\end{lstlisting}

\begin{lstlisting}
> (eqv? "abc" "abc")
#t
\end{lstlisting}

\subsubsection{if}

\begin{lstlisting}[frame=none]
(if test-expr then-expr else-expr)
\end{lstlisting}

\textbf{Description}

Evaluates |test-expr| and evaluates |then-expr| if the result was anything but |#f|, otherwise |else-expr| is evaluated.

\textbf{Examples}

\begin{lstlisting}
> (if (= 1 2) 3 4)
4
\end{lstlisting}

\subsubsection{lambda}

\begin{lstlisting}[frame=none,belowskip=0pt]
(lambda args body)
\end{lstlisting}
\begin{lstlisting}[frame=none,language=SchemeLambda,aboveskip=0pt]
(lambda args body)
\end{lstlisting}

\textbf{Description}

Produces an anonymous procedure with given |args| and |body|.

\textbf{Examples}

\begin{lstlisting}
> ((lambda (x) x) 10)
10
\end{lstlisting}

\subsubsection{let}

\begin{lstlisting}[frame=none]
(let ([id val-expr] ...) body)
\end{lstlisting}

\textbf{Description}

Assigns |val-expr| to |id| for a set of these pairs. After the assignment, |body| is evaluated with these new identifiers.

\textbf{Examples}

\begin{lstlisting}
> (let ([x 10] [y 5]) (+ x y))
15
\end{lstlisting}

\subsubsection{list-ref}

\begin{lstlisting}[frame=none]
(list-ref l p)
\end{lstlisting}

\textbf{Description}

Returns the element of a given list |l| at position |p|. The position if offset at 0.

\textbf{Examples}

\begin{lstlisting}
> (list-ref '(a b (c d) e) 2)
(c d)
\end{lstlisting}

\subsubsection{null?}

\begin{lstlisting}[frame=none]
(null? l)
\end{lstlisting}

\textbf{Description}

Returns |#t| if |l| is an empty list |'()| and |#f| is it is not.

\textbf{Examples}

\begin{lstlisting}
> (null? '())
#t
\end{lstlisting}

\subsubsection{symbol?}

\begin{lstlisting}[frame=none]
(symbol? s)
\end{lstlisting}

\textbf{Description}

Returns |#t| if |l| is a symbol and |#f| is it is not.

\textbf{Examples}

\begin{lstlisting}
> (symbol? 'a)
#t
\end{lstlisting}

\begin{lstlisting}
> (symbol? 1)
#f
\end{lstlisting}

\subsubsection{zero?}

\begin{lstlisting}[frame=none]
(zero? z)
\end{lstlisting}

\textbf{Description}

Returns |#t| if |z| is zero and |#f| is it is not.

\textbf{Examples}

\begin{lstlisting}
> (zero? 0)
#t
\end{lstlisting}

\end{document}

