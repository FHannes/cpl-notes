% Samenvatting van het vak Vergelijkende Studie van Imperatieve Programmeertalen
\documentclass[a4paper]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{parskip}
\usepackage[pdftex]{graphicx}
\usepackage[dutch]{babel}
\usepackage{amsmath}
\usepackage{float}
\usepackage{framed}
\usepackage{varwidth}
\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}

\lstset{
    language=Scheme,
    frame=leftline
}
\lstMakeShortInline[columns=fixed]|

\begin{document}

\begin{titlepage}
    \newpage
    \thispagestyle{empty}
    \frenchspacing
    \hspace{-0.2cm}
    \includegraphics[height=3.4cm]{assets/sedes}
    \hspace{0.2cm}
    \rule{0.5pt}{3.4cm}
    \hspace{0.2cm}
    \begin{minipage}[b]{8cm}
        \Large{Katholieke\newline Universiteit\newline Leuven}\smallskip\newline
        \large{}\smallskip\newline
        \textbf{Department of\newline Computer Science}\smallskip
    \end{minipage}
    \hspace{\stretch{1}}
    \vspace*{3.2cm}\vfill
    \begin{center}
        \begin{minipage}[t]{\textwidth}
            \begin{center}
                \large{\rm{\textbf{\uppercase{Notes}}}}\\
                \large{\rm{Comparative Programming Languages [H0S01a]}}\\
                \large{\rm{Vergelijkende Studie van Imperatieve Programmeertalen [H04L5a]}}
            \end{center}
        \end{minipage}
    \end{center}
    \vfill
    \hfill\makebox[8.5cm][l]{%
        \vbox to 7cm{\vfill\noindent
            {\rm \textbf{Fr\'ed\'eric Hannes}}\\[2mm]
            {\rm Academic year 2015--2016}
        }
    }
\end{titlepage}

\tableofcontents

\newpage

\section{Code}

\subsection{in-S?}

The set $S$ is defined as a set containing any natural number $n$ where $n = 0$ or $n - 3 \in S$. The procedure |in-S?| returns |#t| if a given value is part of the set $S$ and |#f| if it is not.

\begin{lstlisting}
(define in-S?
  (lambda (x)
    (if (zero? x) #t
        (if (< x 3) #f
            (in-S? (- x 3))))))
\end{lstlisting}

\subsection{list-length}

The procedure |list-length| returns the number of elements in a given list. This functionality is available as |length| in the Racket API.

\textbf{list-length} : \textit{Listof(Sym) $\rightarrow$ Int}
\begin{lstlisting}[aboveskip=0pt]
(define list-length
  (lambda (l)
    (if (null? l)
        0
        (+ 1 (list-length (cdr l))))))
\end{lstlisting}

\subsection{nth-element}

The procedure |nth-element| returns the element from a given list at a given position. This functionality is available as |list-ref| in the Racket API.

\textbf{nth-element} : \textit{Listof(Sym) $\times$ Int $\rightarrow$ SchemeVal}
\begin{lstlisting}[aboveskip=0pt]
(define report-list-too-short
  (lambda (n)
    (eopl:error 'nth-element
                "List too short by ~s elements.~%" (+ n 1))))

(define nth-element
  (lambda (l p)
    (if (null? l)
        (report-list-too-short p)
        (if (zero? p)
            (car l)
            (nth-element (cdr l) (- p 1))))))
\end{lstlisting}

\subsection{remove-first}

The procedure |remove-first| returns a given list without the first occurrence of a given symbol. If the list is empty, an empty list is returned. If the list does not contain the given symbol, the given list is returned. This functionality is available as |remv| in the Racket API.

\textbf{remove-first} : \textit{Sym $\times$ Listof(Sym) $\rightarrow$ Listof(Sym)}
\begin{lstlisting}[aboveskip=0pt]
(define remove-first
  (lambda (s l)
    (if (null? l)
        '()
        (if (eqv? (car l) s)
            (cdr l)
            (cons (car l) (remove-first s (cdr l)))))))
\end{lstlisting}

\subsection{occurs-free?}

The procedure |occurs-free?| evaluates a $\lambda$-calculus expression and returns |#t| if a given variable is not a bound variable in that expression. This means that it does not occur as a named parameter for any of the |lambda| expressions in the given expression.

\textbf{occurs-free?} : \textit{Sym $\times$ LcExp $\rightarrow$ Bool}
\begin{lstlisting}[aboveskip=0pt,numbers=left]
(define occurs-free?
  (lambda (var expr)
    (cond
      ((symbol? expr) (eqv? var expr))
      ((eqv? (car expr) 'lambda)
       (and
        (not (eqv? var (caadr expr)))
        (occurs-free? var (caddr expr))))
      (else
       (or
        (occurs-free? var (car expr))
        (occurs-free? var (cadr expr)))))))
\end{lstlisting}

\subsubsection*{Lines reference}

\begin{enumerate}
\setcounter{enumi}{3}
\item If |expr| is a symbol, which is |'| followed by a letter, then the given |var| is not bound if it equals |expr|.
\item If the first element of |expr| is |'lambda|, it is a lambda expression, which we have to dissect.
\setcounter{enumi}{6}
\item |(caadr expr)| returns the parameter of the |lambda| expression, which is referred to as the first (and only) value of the head of the expression. An expression in $\lambda$-calculus can only have a single parameter for each |lambda| expression. In essence, it first performs |cdr| to remove the leading |lambda| from the expression. Then it performs |car| to obtain the head of the expression and finally it will perform another |car| to get the (first) element inside of the head.
\item |(caddr expr)| returns the body of the expression. This is only called if the previous line did not evaluate to |#f|. That means that the head of the expression did not contain |var| and then we can proceed to evaluate the body with a recursive call to |occurs-free?|.
\setcounter{enumi}{10}
\item Aside from the previous cases, $\lambda$-calculus also has expressions that come in pairs of 2. First we will extract the first value of the pair using |car| and evaluate that with a recursive call to |occurs-free?|.
\item To grab the second value of the pair, we have to first get the list of expressions symbols that does not contain the initial symbol, which we've already evaluated using |cdr| and next get the first (and only) symbol of that list using |car|. This line is only executed, if the previous line did not evaluate to |#t|.
\end{enumerate}

\subsection{subst}

The procedure |subst| takes 2 symbols and an s-list, which is defined as a list containing symbols and/or s-lists. The procedure should replace every occurrence of one of the given symbols in the list and all nested lists by the other given symbol, referred to as |old| and |new| respectively.

\textbf{subst} : \textit{Sym $\times$ Sym $\times$ S-list $\rightarrow$ S-list}
\begin{lstlisting}[aboveskip=0pt]
(define subst
  (lambda (new old list)
    (if (null? list)
        '()
        (if (symbol? (car list))
            (cons (if (eqv? (car list) old)
                      new
                      (car list))(subst new old (cdr list)))
            (cons (subst new old (car list)) (subst new old (cdr list)))))))
\end{lstlisting}

\newpage

\section{Exercises}

\subsection{Chapter 1}

\subsubsection*{1.6}

If we reversed the order of checks in |nth-element|, nothing would go wrong, but we would have to perform the initial check in both branches of the |if| for the second check.

\subsubsection*{1.7}

We introduce a helper procedure |nth-element-helper| to easily preserve the original given list.

\begin{lstlisting}
(define report-list-too-short
  (lambda (l n)
    (eopl:error 'nth-element
                "~s does not have ~s element(s).~%" l (+ (length l) (+ n 1)))))

(define nth-element-helper
  (lambda (ol l p)
    (if (null? l)
        (report-list-too-short ol p)
        (if (zero? p)
            (car l)
            (nth-element-helper ol (cdr l) (- p 1))))))

(define nth-element
  (lambda (l p)
    (nth-element-helper l l p)))
\end{lstlisting}

\subsubsection*{1.8}

If the last line of |remove-first| were to be replaced with |(remove-first s (cdr l))|, it would be defined as:

\textbf{remote-first} : \textit{Sym $\times$ Listof(Sym) $\rightarrow$ Listof(Sym)}\\
\textbf{usage:} |(remove-first s l)| returns a list with all elements starting after the first occurrence of the symbol s in the list l.

\subsubsection*{1.9}

We define |remove| as a procedure which removes every occurrence of a given symbol from a given list.

\begin{lstlisting}
(define remove
  (lambda (s l)
    (if (null? l)
        '()
        (if (eqv? (car l) s)
            (remove s (cdr l))
            (cons (car l) (remove s (cdr l)))))))
\end{lstlisting}

\subsubsection*{1.10}

Though typically ``or'' refers to ``inclusive or'', ``exclusive or'' also exists. The statement ``A or B'' for the inclusive variant, will evaluate to true (if it is a logical expression) when either A and/or B are true. The exclusive variant, often referred to as ``xor'', will for ``A xor B'' only evaluate to true if A or B are true, but not when both are true or false.

\subparagraph{NOTE} When we refer to bitwise operations, rather than logical ones, ``A or B'' will perform the same logic as it would for a logical expression, at the binary level. E.g. ``1001 or 0101'' evaluates to 1101, which translates to the decimal system as ``9 or 5 = 13''. ``1001 xor 0101'' evaluates to 1100, which translates to the decimal system as ``9 xor 5 = 12''.

\newpage

\section{Racket (Scheme) Language Reference}

\subsection{API}

\subsubsection{car}

\begin{lstlisting}[frame=none]
(car l)
\end{lstlisting}

\textbf{Description}

Returns the first element of a given list |l|.

\textbf{Examples}

\begin{lstlisting}
> (car '(a b (c d) e))
a
\end{lstlisting}

\subsubsection{cdr}

\begin{lstlisting}[frame=none]
(cdr l)
\end{lstlisting}

\textbf{Description}

Returns the n-1 last elements of a given list |l| as a new list, where n is the length of the list |l|.

\textbf{Examples}

\begin{lstlisting}
> (cdr '(a b (c d) e))
(b (c d) e)
\end{lstlisting}

\subsubsection{cons}

\begin{lstlisting}[frame=none]
(cons a b)
\end{lstlisting}

\textbf{Description}

Returns a pair containing |a| and |b| if they are both symbols. If |b| is a list, it will return that list with |a| appended at the start.

\textbf{Examples}

\begin{lstlisting}
> (cons 'a 'b)
'(a . b)
\end{lstlisting}

\begin{lstlisting}
> (cons 'a '(b))
'(a b)
\end{lstlisting}

\subsubsection{define}

\begin{lstlisting}[frame=none]
(define id expr)
(define (head args) body)
\end{lstlisting}

\textbf{Description}

The first definition binds |id| to the result of |expr|. The second one binds a |head| with |args| to a |body|.

\textbf{Examples}

\begin{lstlisting}
(define x 10)

> x
10
\end{lstlisting}

\begin{lstlisting}
(define (f x)
  (+ x 1))
  
> (f 10)
11
\end{lstlisting}


\subsubsection{eq?}

\begin{lstlisting}[frame=none]
(eq? a b)
\end{lstlisting}

\textbf{Description}

Returns |#t| if 2 given values |a| and |b| refer to the same object. Basic values (and strings) will be compared by value, as they are not represented by objects. To compare by value, refer to |eqv?|.

\textbf{Examples}

\begin{lstlisting}
> (eq? 1 1)
#t
\end{lstlisting}

\begin{lstlisting}
> (eq? 'a 'a)
#f
\end{lstlisting}

\begin{lstlisting}
> (eq? '(a b) '(a b))
#f
\end{lstlisting}

\begin{lstlisting}
> (eq? "abc" "abc")
#t
\end{lstlisting}


\subsubsection{eqv?}

\begin{lstlisting}[frame=none]
(eqv? a b)
\end{lstlisting}

\textbf{Description}

Returns |#t| if 2 given values |a| and |b| are equivalent and |#f| if they are not. This means that the values are equal, but is not to be confused with the procedure |eq?|. This can be used as an alternative to |=| to compare any type of values, as |=| only compares numbers. |eqv?| can not be used to verify if 2 lists are equal, for this refer to |equal?|.

\textbf{Examples}

\begin{lstlisting}
> (eqv? 1 1)
#t
\end{lstlisting}

\begin{lstlisting}
> (eqv? 'a 'a)
#t
\end{lstlisting}

\begin{lstlisting}
> (eqv? '(a b) '(a b))
#f
\end{lstlisting}

\begin{lstlisting}
> (eqv? "abc" "abc")
#t
\end{lstlisting}

\subsubsection{if}

\begin{lstlisting}[frame=none]
(if test-expr then-expr else-expr)
\end{lstlisting}

\textbf{Description}

Evaluates |test-expr| and evaluates |then-expr| if the result was anything but |#f|, otherwise |else-expr| is evaluated.

\textbf{Examples}

\begin{lstlisting}
> (if (= 1 2) 3 4)
4
\end{lstlisting}

\subsubsection{lambda}

\begin{lstlisting}[frame=none,belowskip=0pt]
(lambda args body)
\end{lstlisting}
\begin{lstlisting}[frame=none,language=SchemeLambda,aboveskip=0pt]
(lambda args body)
\end{lstlisting}

\textbf{Description}

Produces an anonymous procedure with given |args| and |body|.

\textbf{Examples}

\begin{lstlisting}
> ((lambda (x) x) 10)
10
\end{lstlisting}

\subsubsection{let}

\begin{lstlisting}[frame=none]
(let ([id val-expr] ...) body)
\end{lstlisting}

\textbf{Description}

Assigns |val-expr| to |id| for a set of these pairs. After the assignment, |body| is evaluated with these new identifiers.

\textbf{Examples}

\begin{lstlisting}
> (let ([x 10] [y 5]) (+ x y))
15
\end{lstlisting}

\subsubsection{list-ref}

\begin{lstlisting}[frame=none]
(list-ref l p)
\end{lstlisting}

\textbf{Description}

Returns the element of a given list |l| at position |p|. The position if offset at 0.

\textbf{Examples}

\begin{lstlisting}
> (list-ref '(a b (c d) e) 2)
(c d)
\end{lstlisting}

\subsubsection{null?}

\begin{lstlisting}[frame=none]
(null? l)
\end{lstlisting}

\textbf{Description}

Returns |#t| if |l| is an empty list |'()| and |#f| is it is not.

\textbf{Examples}

\begin{lstlisting}
> (null? '())
#t
\end{lstlisting}

\subsubsection{symbol?}

\begin{lstlisting}[frame=none]
(symbol? s)
\end{lstlisting}

\textbf{Description}

Returns |#t| if |l| is a symbol and |#f| is it is not.

\textbf{Examples}

\begin{lstlisting}
> (symbol? 'a)
#t
\end{lstlisting}

\begin{lstlisting}
> (symbol? 1)
#f
\end{lstlisting}

\subsubsection{zero?}

\begin{lstlisting}[frame=none]
(zero? z)
\end{lstlisting}

\textbf{Description}

Returns |#t| if |z| is zero and |#f| is it is not.

\textbf{Examples}

\begin{lstlisting}
> (zero? 0)
#t
\end{lstlisting}

\end{document}

